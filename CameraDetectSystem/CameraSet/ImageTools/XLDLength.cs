using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using HalconDotNet;
using System.Windows.Forms;
using System.Xml.Serialization;
using System.Diagnostics;
namespace CameraDetectSystem
{
    [Serializable]
    public class XldLength : ImageTools
    {
        public XldLength()
        {
            HOperatorSet.GenEmptyObj(out RegionToDisp);
            RegionToDisp.Dispose();
        }
        public XldLength(HObject Image, Algorithm al)
        {
            HOperatorSet.GenEmptyObj(out RegionToDisp);
            RegionToDisp.Dispose();
            this.Image = Image; this.algorithm = al; vOrh = "h";
            pixeldist = 1;
        }

        public string vOrh { set; get; }

        public HTuple Length
        {
            get { return _length; }
            set { _length = value; }
        }
        [NonSerialized]
        HTuple _length;
        [NonSerialized]
        private HTuple Row1, Row2, Column1, Column2;
        public double DRow1, DRow2, DColumn1, DColumn2;
        public override void draw()
        {
            HOperatorSet.SetColor(this.LWindowHandle, "cyan");
            HOperatorSet.SetDraw(this.LWindowHandle, "margin");
            HOperatorSet.DrawRectangle1(this.LWindowHandle, out Row1, out Column1, out Row2, out Column2);
            DRow1 = Row1.D;
            DRow2 = Row2.D;
            DColumn1 = Column1.D;
            DColumn2 = Column2.D;
        }
        public void xldLength(HObject ho_Image, HObject ho_Rectangle, out HObject ho_RectangleOut,
          HTuple hv_Phi, out HTuple hv_Distance_Measure_01_0)
        {



            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];
            long SP_O = 0;

            // Local iconic variables 

            HObject ho_ImageOut;


            // Local control variables 

            HTuple hv_s, hv_Area, hv_Row1, hv_Column1;
            HTuple hv_length, hv_Alignment, hv_AmplitudeThreshold;
            HTuple hv_ROIWidth, hv_LineRowStart_Measure_01_0, hv_LineColumnStart_Measure_01_0;
            HTuple hv_LineRowEnd_Measure_01_0, hv_LineColumnEnd_Measure_01_0;
            HTuple hv_LineRowStart_Measure_01_0_Aligned, hv_LineColumnStart_Measure_01_0_Aligned;
            HTuple hv_LineRowEnd_Measure_01_0_Aligned, hv_LineColumnEnd_Measure_01_0_Aligned;
            HTuple hv_TmpCtrl_Row, hv_TmpCtrl_Column, hv_TmpCtrl_Dr;
            HTuple hv_TmpCtrl_Dc, hv_TmpCtrl_Phi, hv_TmpCtrl_Len1;
            HTuple hv_TmpCtrl_Len2, hv_MsrHandle_Measure_01_0, hv_Row_Measure_01_0;
            HTuple hv_Column_Measure_01_0, hv_Amplitude_Measure_01_0;

            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_RectangleOut);
            HOperatorSet.GenEmptyObj(out ho_ImageOut);

            ho_ImageOut.Dispose();
            HOperatorSet.CopyObj(ho_Image, out ho_ImageOut, 1, -1);
            hv_s = (hv_Phi * 180) / 3.14;


            HOperatorSet.AreaCenter(ho_Rectangle, out hv_Area, out hv_Row1, out hv_Column1);

            hv_length = 1000;
            HOperatorSet.VectorAngleToRigid(hv_length, 0, (new HTuple(90)).TupleRad(), hv_Row1,
                hv_Column1, hv_Phi, out hv_Alignment);

            //Code generated by Measure 01
            //Prepare measurement
            hv_AmplitudeThreshold = 15;
            hv_ROIWidth = 15;
            HOperatorSet.SetSystem("int_zooming", "true");
            //Coordinates for line Measure 01 [0]
            hv_LineRowStart_Measure_01_0 = 0;
            hv_LineColumnStart_Measure_01_0 = 0;
            hv_LineRowEnd_Measure_01_0 = hv_length * 2;
            hv_LineColumnEnd_Measure_01_0 = 0;
            //gen_region_line (RegionLines, LineRowStart_Measure_01_0, LineColumnStart_Measure_01_0, LineRowEnd_Measure_01_0, LineColumnEnd_Measure_01_0)

            //***************************************************************
            //* The code which follows is to be executed once / measurement *
            //***************************************************************
            //The image is assumed to be made available in the
            //variable last displayed in the graphics window
            OTemp[SP_O] = ho_ImageOut.CopyObj(1, -1);
            SP_O++;
            ho_ImageOut.Dispose();
            HOperatorSet.CopyObj(OTemp[SP_O - 1], out ho_ImageOut, 1, 1);
            OTemp[SP_O - 1].Dispose();
            SP_O = 0;
            //*************
            //* ATTENTION *
            //*************
            //For alignment purposes,it will be necessary at this point to obtain
            //a transformation from the image and store it in 'Alignment'. One possible way
            //of doing this is to use the matching assistant.
            //
            //Align coordinates of line Measure 01 [0]
            HOperatorSet.AffineTransPoint2d(hv_Alignment, hv_LineRowStart_Measure_01_0, hv_LineColumnStart_Measure_01_0,
                out hv_LineRowStart_Measure_01_0_Aligned, out hv_LineColumnStart_Measure_01_0_Aligned);
            HOperatorSet.AffineTransPoint2d(hv_Alignment, hv_LineRowEnd_Measure_01_0, hv_LineColumnEnd_Measure_01_0,
                out hv_LineRowEnd_Measure_01_0_Aligned, out hv_LineColumnEnd_Measure_01_0_Aligned);
            //Convert coordinates to rectangle2 type
            hv_TmpCtrl_Row = 0.5 * (hv_LineRowStart_Measure_01_0_Aligned + hv_LineRowEnd_Measure_01_0_Aligned);
            hv_TmpCtrl_Column = 0.5 * (hv_LineColumnStart_Measure_01_0_Aligned + hv_LineColumnEnd_Measure_01_0_Aligned);
            hv_TmpCtrl_Dr = hv_LineRowStart_Measure_01_0_Aligned - hv_LineRowEnd_Measure_01_0_Aligned;
            hv_TmpCtrl_Dc = hv_LineColumnEnd_Measure_01_0_Aligned - hv_LineColumnStart_Measure_01_0_Aligned;
            hv_TmpCtrl_Phi = hv_TmpCtrl_Dr.TupleAtan2(hv_TmpCtrl_Dc);
            hv_TmpCtrl_Len1 = 0.5 * ((((hv_TmpCtrl_Dr * hv_TmpCtrl_Dr) + (hv_TmpCtrl_Dc * hv_TmpCtrl_Dc))).TupleSqrt()
                );
            hv_TmpCtrl_Len2 = hv_ROIWidth.Clone();
            //Create measure for line Measure 01 [0]
            //Attention: This assumes all images have the same size!
            HOperatorSet.GenMeasureRectangle2(hv_TmpCtrl_Row, hv_TmpCtrl_Column, hv_TmpCtrl_Phi,
                hv_TmpCtrl_Len1, hv_TmpCtrl_Len2, 819, 460, "nearest_neighbor", out hv_MsrHandle_Measure_01_0);
            ho_RectangleOut.Dispose();
            HOperatorSet.GenRectangle2(out ho_RectangleOut, hv_TmpCtrl_Row, hv_TmpCtrl_Column,
                hv_TmpCtrl_Phi, hv_TmpCtrl_Len1, 1);

            //Execute measurements
            HOperatorSet.MeasurePos(ho_ImageOut, hv_MsrHandle_Measure_01_0, 4, 15, "all",
                "all", out hv_Row_Measure_01_0, out hv_Column_Measure_01_0, out hv_Amplitude_Measure_01_0,
                out hv_Distance_Measure_01_0);
            //Do something with the results
            HOperatorSet.CloseMeasure(hv_MsrHandle_Measure_01_0);
            ho_ImageOut.Dispose();

            return;
        }
        private void action()
        {
            _length = 0;
            // Local iconic variables 

            HObject ho_Rectangle, ho_ImageReduced;
            HObject ho_Arrow, region;
            HObject ho_RegionTrans;
            HTuple hv_Row, hv_Column, hv_Phi, hv_Length1, hv_Length2, hv_Distance_Measure_01_0;
            // Local control variables 
            HTuple hv_Number;
            HOperatorSet.GenEmptyObj(out region);
            HOperatorSet.GenEmptyObj(out ho_Rectangle);
            HOperatorSet.GenEmptyObj(out ho_ImageReduced);
            HOperatorSet.GenEmptyObj(out ho_Arrow);
            HOperatorSet.GenEmptyObj(out ho_RegionTrans);
            try
            {

                ho_Rectangle.Dispose();
                HOperatorSet.GenRectangle1(out ho_Rectangle, this.DRow1, this.DColumn1, this.DRow2, this.DColumn2);
                HOperatorSet.Intersection(algorithm.Region, ho_Rectangle, out region);
                this.result = new HTuple();
                ho_Arrow.Dispose();
                ho_RegionTrans.Dispose();
                HOperatorSet.ShapeTrans(region, out ho_RegionTrans, "rectangle2");
                HOperatorSet.SmallestRectangle2(ho_RegionTrans, out hv_Row, out hv_Column, out hv_Phi,
                    out hv_Length1, out hv_Length2);
                ho_Rectangle.Dispose();
                HOperatorSet.GenRectangle2(out ho_Rectangle, hv_Row, hv_Column, hv_Phi, hv_Length1,
                    hv_Length2);

                xldLength(algorithm.Image, ho_Rectangle, out ho_Arrow, hv_Phi, out hv_Distance_Measure_01_0);
                this._length = hv_Distance_Measure_01_0;
                if (algorithm.Region.IsInitialized())
                {
                    HOperatorSet.CountObj(region, out hv_Number);
                    if ((int)(new HTuple(hv_Number.TupleEqual(1))) != 0)
                    {
                        this.Result = this.Result.TupleConcat("XLDlength");
                        this.Result = this.Result.TupleConcat(this._length * pixeldist);
                    }
                    else
                    {
                        this.Result = this.Result.TupleConcat("XLDlength");
                        this.Result = this.Result.TupleConcat(0);
                    }
                    //HOperatorSet.SetColor(this.LWindowHandle, "green");
                    //HOperatorSet.DispObj(ho_Arrow, this.LWindowHandle);
                    if (ho_Arrow.IsInitialized())
                    {
                        RegionToDisp.Dispose();
                        if (RegionToDisp.IsInitialized())
                            HOperatorSet.ConcatObj(ho_Arrow, RegionToDisp, out RegionToDisp);
                        else
                        {
                            HOperatorSet.CopyObj(ho_Arrow, out RegionToDisp, 1, 1);
                            HOperatorSet.Union1(RegionToDisp, out RegionToDisp);
                        }
                    }
                }

            }
            catch (Exception e)
            {
                this.Result = new HTuple();
                this.Result = this.Result.TupleConcat("XLDlength");
                this.Result = this.Result.TupleConcat(0);
            }
            finally
            {
                algorithm.Region.Dispose();
                region.Dispose();
                ho_Rectangle.Dispose();
                ho_ImageReduced.Dispose();
                ho_Arrow.Dispose();
                ho_RegionTrans.Dispose();
            }
        }
        public override bool method()
        {
            try
            {
                if (base.method())
                {
                    action();
                    return true;
                }
                else
                {
                    return false;
                }
            }
            catch (Exception e)
            {
                Debug.Print(e.Message);
                return false;
            }
        }

    }
}
